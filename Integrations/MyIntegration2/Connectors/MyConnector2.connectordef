{"IsEnabled":true,"IsCustom":true,"Integration":"MyIntegration2","DocumentationLink":null,"Name":"MyConnector2","Description":"","Creator":"ab30ec94-1287-4e6a-90ac-5546d60a2d7f","Script":"from SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyConnectorsDataModel import AlertInfo\nfrom SiemplifyUtils import output_handler, unix_now\nfrom random import randrange\n\nimport uuid\nimport sys\n\n#==============================================================================\n# This is a Connector Template + mock generator. This file objective is to demonstrate how to build a connector, and exmplain the objective of each field.\n# All the data generated here, is MOCK data. Enjoy.\n#==============================================================================\n\nCONNECTOR_NAME = \"ConnectorTemplate\"\nVENDOR = \"DummyVendor\"\nPRODUCT = \"DummyProduct\"\nRULE_GENERATOR_EXAMPLE = \"Example_Rule_1\"\nRANDOM_ALERT_COUNT_MAX = 3\nRANDOM_EVENT_COUNT_PER_ALERT_MAX = 5\n\n@output_handler\ndef main(is_test_run):\n    alerts = [] # The main output of each connector run\n    siemplify = SiemplifyConnectorExecution() # Siemplify main SDK wrapper\n    siemplify.script_name = CONNECTOR_NAME\n\n    if (is_test_run):\n        siemplify.LOGGER.info(\"***** This is an \\\"IDE Play Button\\\"\\\\\\\"Run Connector once\\\" test run ******\")\n\n    siemplify.LOGGER.info(\"==================== Main - Param Init ====================\")\n\n    param_a = siemplify.extract_connector_param(\"Param A\", default_value=None, input_type=int, is_mandatory=False, print_value=True)\n\n    siemplify.LOGGER.info(\"------------------- Main - Started -------------------\")\n\n    # ... CUSTOM LOGIC HERE ....\n    # In this template example, we create a random number of dummy alerts:\n    for alert_id in [str(uuid.uuid4()) for i in range(randrange(RANDOM_ALERT_COUNT_MAX+1))]:\n        try:\n            # ... CUSTOM LOGIC HERE ....\n            # ... CUSTOM LOGIC HERE ....\n            alert_example = fetch_alert(siemplify, alert_id)\n            # ... CUSTOM LOGIC HERE ....\n            # ... CUSTOM LOGIC HERE ....\n\n            if alert_example:\n                alerts.append(alert_example)\n                siemplify.LOGGER.info(\"Added Alert {} to package results\".format(alert_id))\n\n        except Exception as e:\n            siemplify.LOGGER.error(\"Failed to process alert {}\".format(alert_id), alert_id=alert_id)\n            siemplify.LOGGER.exception(e)\n\n    siemplify.LOGGER.info(\"------------------- Main - Finished -------------------\")\n    siemplify.return_package(alerts)\n\n\ndef fetch_alert(siemplify, alert_id):\n    \"\"\"Returns an alert, which is an aggregation of basic events. (ie: Arcsight's correlation, QRadar's Offense)\"\"\"\n    siemplify.LOGGER.info(\"-------------- Started processing Alert {}\".format(alert_id), alert_id=alert_id)\n\n    alert_info = AlertInfo()\n\n    # ----------------------------- Alert Fields initilization START -----------------------------\n    # ... Replace this DUMMY VALUES !!! ...\n\n    # Each alert_info has a unique key composed of alert_info.name+alert_info.display_id. This key is used to validate data is digested only once by the Siemplify System - to avoid duplicates.\n    # If an alert_info has a uniqe_key that has already been digested, it will be ignored.\n    # The uniqueness must be persistent, even after server restart\\ refetching of the same alert, multiple runs of the same API queries, etc.\n    alert_info.display_id = alert_id\n    alert_info.ticket_id = alert_id  # In default, ticket_id = display_id. But, if for some reason the external alert id, is different then the composite's key display_id, you can save the original external alert id in this \"ticket_id\" field.\n    alert_info.name = \"Random Alert Name \" + str(uuid.uuid4())\n    alert_info.rule_generator = RULE_GENERATOR_EXAMPLE  # Describes the name of the siem's rule, that caused the aggregation of the alert.\n    alert_info.start_time = unix_now()  # Times should be saved in UnixTime. You may use SiemplifyUtils.convert_datetime_to_unix_time, or SiemplifyUtils.convert_string_to_datetime\n    alert_info.end_time = unix_now() # Times should be saved in UnixTime. You may use SiemplifyUtils.convert_datetime_to_unix_time, or SiemplifyUtils.convert_string_to_datetime\n    alert_info.priority = 60  # Informative = -1,Low = 40,Medium = 60,High = 80,Critical = 100.\n    alert_info.device_vendor = VENDOR  # This field, may be fetched from the Original Alert. If you build this alert manualy, Describe the source vendor of the data. (ie: Microsoft, Mcafee)\n    alert_info.device_product = PRODUCT  # This field, may be fetched from the Original Alert. If you build this alert manualy, Describe the source product of the data. (ie: ActiveDirectory, AntiVirus)\n    alert_info.environment = siemplify.context.connector_info.environment # This field, gets the Environment of the specific connector execution.\n    # ----------------------------- Alert Fields initilization END -----------------------------\n\n    siemplify.LOGGER.info(\"---------- Events fetching started for alert  {}\".format(alert_id))\n\n    # ... CUSTOM LOGIC HERE ....\n    # In this template example, for each alert, we create a random number of dummy events:\n    for event_id in [str(uuid.uuid4()) for i in range(randrange(RANDOM_EVENT_COUNT_PER_ALERT_MAX+1))]:\n        try:\n\n            # ... CUSTOM LOGIC HERE ....\n            dummy_event = fetch_event(siemplify, alert_id, event_id)\n            # ... CUSTOM LOGIC HERE ....\n\n            if dummy_event:\n                alert_info.events.append(dummy_event)\n                siemplify.LOGGER.info(\"Added Event {} to Alert {}\".format(event_id, alert_id))\n\n        except Exception as e:\n            siemplify.LOGGER.error(\"Failed to process event {}\".format(event_id), alert_id=alert_id)\n            siemplify.LOGGER.exception(e)\n\n    siemplify.LOGGER.info(\"---------- Events fetching finished for alert {}\".format(alert_id))\n\n    siemplify.LOGGER.info(\"-------------- Finished processing Alert {}\".format(alert_id), alert_id=alert_id)\n    return alert_info\n\n\ndef fetch_event(siemplify, alert_id, event_id):\n    siemplify.LOGGER.info(\"--- Started processing Event:  alert_id: {} | event_id: {}\".format(alert_id, event_id))\n    event = {}\n\n    # ----------- Mandatory Fields ---------------\n    # A valid event must have a \"Start Time\", \"End Time\", \"Name\", and \"Device Product\". Their name is not important (What ever it is, it will be mapped).\n    # ie: \"Start Time\" may be called \"Start Time\", \"StartTime\", \"start_time\", \"johnDoeStartTime\"\n    event[\"StartTime\"] = unix_now() # Times should be saved in UnixTime. You may use SiemplifyUtils.convert_datetime_to_unix_time, or SiemplifyUtils.convert_string_to_datetime\n    event[\"EndTime\"] = unix_now() # Times should be saved in UnixTime. You may use SiemplifyUtils.convert_datetime_to_unix_time, or SiemplifyUtils.convert_string_to_datetime\n    event[\"name\"] = \"RandomEventName \" + str(uuid.uuid4())\n    event[\"device_product\"] = \"RandomProductExample{}\".format(randrange(3))  # ie: \"device_product\" is the field name in arcsight that describes the product the event originated from.\n    # ----------------------------- ---------------\n\n     # usually, the most intresting fields are (again, their precise name, may vary between siems.\n    # You are not expected to fill them yourself, just pass them along from the siem. Since this is a dummy generator, We create them manaualy with made up name (PascalCase\\CcmelCase doesn't matter)\n    event[\"SourceHostName\"] = \"DummyHostSrc\"\n    event[\"DestinationHostName\"] = \"DummyHostDest\"\n    event[\"SourceAddress\"] = \"10.0.0.\"+str(randrange(254))\n    event[\"DestinationAddress\"] = \"55.44.33.\"+str(randrange(254))\n    # event[\"SourceUserName\"] =\n    # event[\"DestinationUserName\"] =\n    # event[\"FileName\"] =\n\n    siemplify.LOGGER.info(\"--- Finished processing Event: alert_id: {} | event_id: {}\".format(alert_id, event_id))\n\n    return event\n\n\nif __name__ == \"__main__\":\n    # Connectors are run in iterations. The interval is configurable from the ConnectorsScreen UI.\n    is_test_run = not (len(sys.argv) < 2 or sys.argv[1] == 'True')\n    main(is_test_run)","Version":4,"MappingRules":[],"ProductToVisualFamilyRecords":[],"SimulationUseCases":{"CasesForUseCase":[],"UseCaseName":null},"Parameters":[{"ConnectorDefinitionId":3,"IsMandatory":true,"IsAdvanced":false,"DefaultValue":"a","Name":"DeviceProductField","Type":2,"Mode":0,"Description":"The field name used to determine the device product"},{"ConnectorDefinitionId":3,"IsMandatory":true,"IsAdvanced":false,"DefaultValue":"a","Name":"EventClassId","Type":2,"Mode":0,"Description":"The field name used to determine the event name (sub-type)"},{"ConnectorDefinitionId":3,"IsMandatory":true,"IsAdvanced":false,"DefaultValue":"30","Name":"PythonProcessTimeout","Type":2,"Mode":0,"Description":"The timeout limit (in seconds) for the python process running current script"}],"Rules":[],"IsConnectorRulesSupported":true,"IsSystem":false,"PythonVersion":"None"}